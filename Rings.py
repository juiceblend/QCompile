import math
import cmath
from sympy import Matrix
import numpy as np
from mpmath import mp

'''
Define classes implementing arithmetic operations for the rings Z[omega], Z[tau]
where omega is the first 10th root of unity and tau = 1/phi

Z[tau] is the real subring of Z[omega]

Also implements multiplication of exact matrices, which are the group of 2x2 matrices 
generated by braiding Fibonacci anyons
'''

# set decimal precision
mp.dps = 50


class Zomega:

    # Can either initialize from coords a,b,c,d or from an element of Z[tau]

    def __init__(self, a, b, c, d):
        self.a = a
        self.b = b
        self.c = c
        self.d = d

    def fromTau(t):
        o = Zomega(t.a, 0, t.b, -t.b)
        return o
    
    # ------------------------------------------------------------------------
    # Overload arithmetic operations

    def __mul__(self, s):
        output = self.mult_matrix(self.a, self.b, self.c, self.d) * Matrix([s.a, s.b, s.c, s.d])
        return Zomega(output[0],output[1],output[2],output[3])

    def mult_matrix(self, a, b, c, d):
        return Matrix([
            [a,  -d, -c-d, -b-c],
            [b, a+d,    c,  b-d],
            [c, b-d,  a-c,   -b],
            [d, c+d,  b+c,  a+b]
        ])
    
    def __floordiv__(self, s):
        output = self/s
        return Zomega(int(round(output.a)),
                      int(round(output.b)),
                      int(round(output.c)),
                      int(round(output.d)))
    
    def __truediv__(self, s):
        output = self.mult_matrix(s.a, s.b, s.c, s.d)**(-1) * Matrix([self.a, self.b, self.c, self.d])
        return Zomega(output[0],output[1],output[2],output[3])
    
    def __add__(self, s):
        a = self.a + s.a
        b = self.b + s.b
        c = self.c + s.c
        d = self.d + s.d
        return Zomega(a,b,c,d)
    
    def __sub__(self, s):
        a = self.a - s.a
        b = self.b - s.b
        c = self.c - s.c
        d = self.d - s.d
        return Zomega(a,b,c,d)
    
    def __pow__(self, k):
        T = Zomega(1, 0, 0, 0)
        for i in range(k):
            T = self.__mul__(T)
        else:
            inv = Zomega(1,0,0,0)/self
            for i in range(-k):
                T = T * inv
            
            T.a, T.b, T.c, T.d = int(T.a), int(T.b), int(T.c), int(T.d)
        return T
    
    def __eq__(self, other):
        return (self.a, self.b, self.c, self.d) == (other.a, other.b, other.c, other.d)
    
    # --------------------------------------------------------

    # Define various misc operations/attributes

    def dot(self):
        a = self.a + self.d
        b = -self.c - self.d
        c = self.d
        d = self.b - self.d
        return Zomega(a,b,c,d)

    def star(self):
        return self.dot().dot()
    
    def N(self):
        return (self * self.dot() * self.dot().dot() * self.dot().dot().dot()).a
    
    def Ni(self):
        return Ztau.fromOmega(self*self.star())
    
    def abs(self):
        omega = mp.exp(mp.mpc(1j) * mp.pi / mp.mpc(5,0))
        return abs(self.a + self.b*omega + self.c*(omega**2) + self.d*(omega**3))

    def value(self):
        omega = mp.exp(mp.mpc(1j) * mp.pi / mp.mpc(5,0))
        return self.a + self.b*omega + self.c*(omega**2) + self.d*(omega**3)

    def mu(self):
        return Ztau.fromOmega(self.dot() * self.dot().dot().dot())
    
    def G(self):
        return int(round((Ztau.fromOmega(self * self.star()) + Ztau.fromOmega(self.dot() * self.dot().dot().dot())).value()))

    def __str__(self):
        return "({0} + {1}\u03C9 + {2}\u03C9\u00B2 + {3}\u03C9\u00B3)".format(self.a, self.b, self.c, self.d)
    

class Ztau:

    # Can either initialize from coords a,b or from an element of Z[omega]

    def __init__(self, a, b):
        self.a = a
        self.b = b

    def fromOmega(o):
        return Ztau(o.a+int(o.b/2), int((o.b+o.c-o.d)/2))
    
    
    # ------------------------------------------------------------------------
    # Overload arithmetic operations
    
    def __mul__(self, s):
        a = self.a*s.a + self.b*s.b
        b = self.a*s.b + self.b*s.a - self.b*s.b
        return Ztau(a,b)

    def __add__(self, s):
        a = self.a + s.a
        b = self.b + s.b
        return Ztau(a,b)
    
    def __sub__(self, s):
        a = self.a - s.a
        b = self.b - s.b
        return Ztau(a,b)
    
    def __pow__(self, k):
        T = Ztau(1, 0)
        if k >= 0:
            for i in range(k):
                T = self.__mul__(T)
        else:
            inv = Ztau(1,0)/self
            for i in range(-k):
                T = T * inv
            
            # cast to int for convenience in our applications - this shouldn't happen in general
            T.a = int(T.a)
            T.b = int(T.b) 
        return T

    def __floordiv__(self, s):
        # by inverting the system of equations get e, f such that (c+dt)(e+ft) = (a+bt)
        # then take the int of e,f
        a, b, c, d = self.a, self.b, s.a, s.b
        e = (a*(c-d) - b*d)/(c**2 - c*d - d**2)
        f = (-a*d + b*c)/(c**2 - c*d - d**2)

        return Ztau(int(round(e)), int(round(f)))
    
    def __truediv__(self, s):
        # by inverting the system of equations get e, f such that (c+dt)(e+ft) = (a+bt)
        # then take the int of e,f
        a, b, c, d = self.a, self.b, s.a, s.b
        e = (a*(c-d) - b*d)/(c**2 - c*d - d**2)
        f = (-a*d + b*c)/(c**2 - c*d - d**2)

        return Ztau(e, f)
    
    def __eq__(self, other):
        return (self.a, self.b) == (other.a, other.b)
        

    # ------------------------------------------------------------------------
    # Misc Operations

    def dot(self):
        a = self.a - self.b
        b = -self.b
        return Ztau(a,b)
    
    def N(self):
        return self.__mul__(self.dot()).a
    
    def mu(self):
        return self.a*self.b
    
    def value(self):
        tau = (mp.sqrt(mp.mpf(5)) - 1)/2
        return self.a + self.b * tau

    def __str__(self):
        return "({0} + {1}\u03C4)".format(self.a, self.b)
    

class Exact_U: 
    def __init__(self, u, v, k):
        self.u = u
        self.v = v
        self.k = k
    
    def __mul__(self, A):
        omega = Zomega(0,1,0,0)
        tau = Zomega(0,0,1,-1)
        return Exact_U(self.u*A.u + self.v.star()*A.v*tau*(omega**self.k), 
                 self.v*A.u - self.u.star()*A.v*(omega**self.k), 
                 (self.k + A.k + 5)%10)
    
    def __pow__(self, k):
        T = Exact_U(Zomega(1,0,0,0), Zomega(0,0,0,0), 5)
        for i in range(k):
            T = self.__mul__(T)
        return T
    
    def __eq__(self, other):
        return (self.u == other.u) and (self.v == other.v) and (self.k%10 == other.k%10)
    
    def mu(self):
        return self.u.mu()
    
    def G(self):
        return self.u.G()
    
    def value(self):
        tau = (mp.sqrt(mp.mpf(5)) - 1)/2
        omega = mp.exp(mp.mpc(1j) * mp.pi / mp.mpc(5,0))
        return np.array([
            [self.u.value(), self.v.star().value()*math.sqrt(tau)*omega**self.k],
            [self.v.value()*math.sqrt(tau), -1*self.u.star().value()*omega**self.k]
        ])
    
    def __str__(self):
        return "U({0},{1},{2})".format(self.u, self.v, self.k)
    
